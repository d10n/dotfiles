#!/bin/bash
[[ -z "${ORIGINAL_VARS}" ]] && ORIGINAL_VARS="$(declare -px)"
typeset +x ORIGINAL_VARS
[[ -n "${FIXPATH}" ]] && PATH="$FIXPATH" && unset FIXPATH

# Don't add these commands to the history
HISTIGNORE="&:[ ]*:ls:bg:fg:exit:reset:clear:which"

# Avoid duplicate history entries
HISTCONTROL="ignoreboth:erasedups"

# Huge history. Doesn't appear to slow things down, so why not?
HISTSIZE=500000
HISTFILESIZE=100000

# Use standard ISO 8601 timestamp
# %F equivalent to %Y-%m-%d
# %T equivalent to %H:%M:%S (24-hours format)
HISTTIMEFORMAT='%F %T '

# Save multi-line commands as one command
shopt -s cmdhist

# Append to the history file, don't overwrite it
shopt -s histappend

# Disable ^s and ^q
stty -ixon -ixoff
bind -r '\C-s'
bind -r '\C-q'

# Turn on recursive globbing (enables ** to recurse all directories)
# Requires Bash >= 4
shopt -s globstar 2> /dev/null

# Not set because having cd be in front of every directory change is useful for searching history
# cd to a directory by typing just the directory
# Requires Bash >= 4
#shopt -s autocd 2> /dev/null

# This defines where cd looks for targets
# Add the directories you want to have fast access to, separated by colon
# Ex: CDPATH=".:~:~/projects" will look for targets in the current working directory, in home and in the ~/projects folder
CDPATH="."

# Not set because I don't want it set in zsh and I want consistency
# cd to variables; with foo=~/code/foo, `cd foo` works from any folder that doesn't contain its own foo folder
#shopt -s cdable_vars
#dotfiles="$HOME/.config/dotfiles"

setup_completion() {
    if [[ -f /usr/share/git/completion/git-completion.bash ]]; then
        . /usr/share/git/completion/git-completion.bash
    elif [[ -f /usr/local/share/git/completion/git-completion.bash ]]; then
        . /usr/local/share/git/completion/git-completion.bash
    elif [[ -f /usr/share/bash-completion/completions/git ]]; then
        . /usr/share/bash-completion/completions/git
    elif [[ -f /usr/local/share/bash-completion/completions/git ]]; then
        . /usr/local/share/bash-completion/completions/git
    elif [[ -f /Library/Developer/CommandLineTools/usr/share/git-core/git-completion.bash ]]; then
        . /Library/Developer/CommandLineTools/usr/share/git-core/git-completion.bash
    fi
}
setup_completion && unset -f setup_completion

mkcd() {
    local dir="$*"
    mkdir -p "$dir" && cd "$dir"
}

mvcd() {
    (( $# > 1 )) && [[ -d "${@: -1}" ]] && mv "$@" && builtin cd "${@: -1}"
}

cd() {
    local top
    [[ -z "$@" ]] && set_iterm_tab_rgb
    { [[ "$1" = ":/" ]] && top="$(git rev-parse --show-cdup)." && builtin cd "$top"; } || \
    { [[ -f "$1" ]] && builtin cd "$(dirname "$1")"; } || \
    builtin cd "$@"
}

which() {
    local which_out which_exit
    which_out="$(builtin type -a "$@")"
    which_exit="$?"
    echo -E "$which_out" | while IFS=$'\n' read -r line; do
        if [[ "$line" = *" is /"* ]] && [[ -x "${line/#* is /}" ]]; then
            echo -En "${line%% is *} is "
            ls -la "${line/#* is /}"
        else
            echo -E "$line"
        fi
    done
    return "$which_exit"
}

git() {
    local code
    if [[ "$1" = "checkout" ]] && [[ "$2" = "-i"* ]]; then
        git-checkout-i "$@"; return
    fi
    if [[ "$1" = "browse" ]]; then
        git-browse "$@"; return
    fi
    if [[ "$1" = "stash" ]] && [[ "$2" = "list" ]] && [[ "$3" = "-i" ]]; then
        git-stash-list-i "$@"; return
    fi
    if [[ "$1" = "stash" ]] && [[ "$2" = "list" ]]; then
        shift;shift;
        command git stash list --format='%C(auto)%h %gd %C(dim red)[%C(reset)%C(red)%cr%C(dim red)]%C(reset) %C(auto)%<(70,trunc)%s %C(dim cyan)<%C(reset)%C(cyan)%an%C(dim cyan)>%C(reset)' "$@"
        return
    fi
    if [[ "$1" = "commit" ]] && [[ "$2" = "-a"* ]]; then
        if ! command git diff-index --cached --quiet HEAD -- && \
            ! command git diff-files --quiet; then
            echo >&2 $'\e[0;31mERROR!\e[0m Changes are already staged. Preventing git commit -a'
            echo >&2 $'\e[0;31mERROR!\e[0m Run git commit without -a or run git reset HEAD first'
            return 1
        fi
    fi
    command git "$@"
    code="$?"
    if [[ "$1" = "commit" ]] && (( ! code )); then
        printf 'Commit subject length: '
        command git log -1 --format="%s" | tr -d '\n' | wc -m | awk '{print $1}'
    fi
    return "$code"
}

git-browse() {
    # Press enter to view a commit's diff, q to exit the diff pager, and esc to exit fzf
    if ! command -v fzf &>/dev/null; then
        printf >&2 "\e[0;31mCan't git browse without installation of fzf\e[0m\n\n"
        command git "$@"
        return
    fi
    shift
    command git log --graph --color=always \
        --format='%C(auto)%h %C(dim red)[%C(reset)%C(red)%cr%C(dim red)]%C(reset)%C(auto)%d %s %C(dim cyan)<%C(reset)%C(cyan)%an%C(dim cyan)>%C(reset)' "$@" |
        fzf --ansi --no-sort --reverse --tiebreak=index \
        --bind 'enter:execute: echo {} |
            sed "s#^[* /|\]*\([a-f0-9]*\).*#\1#" | head -1 |
            xargs -I % sh -c "git show --color=always % | less -R"'
    return 0
}

git-stash-list-i() {
    # Press enter to view a stash's diff, q to exit the diff pager, and esc to exit fzf
    if ! command -v fzf &>/dev/null; then
        printf >&2 "\e[0;31mCan't git stash list -i without installation of fzf\e[0m\n\n"
        command git "$@"
        return
    fi
    command git stash list --color=always \
        --format='%C(auto)%h %gd %C(dim red)[%C(reset)%C(red)%cr%C(dim red)]%C(reset) %C(auto)%<(70,trunc)%s %C(dim cyan)<%C(reset)%C(cyan)%an%C(dim cyan)>%C(reset)' |
        fzf --ansi --no-sort --reverse --tiebreak=index \
        --bind 'enter:execute: echo {} |
            sed "s#\([a-f0-9]*\).*#\1#" | head -1 |
            xargs -I % sh -c "git show --color=always % | less -R"'
    return 0
}

git-checkout-i() {
    local one refs cmd format branches line_count term_height fzf_height branch checkout_command
    if ! command -v fzf &>/dev/null; then
        printf >&2 "\e[0;31mCan't git checkout -i without installation of fzf\e[0m\n\n"
        command git "$@"
        return
    fi

    shift
    one="${1/#-i/-}"; shift; [[ "$one" != "-" ]] && set -- "$one" "$@"
    case "$1" in
        -h | --help)
            printf >&2 'Usage:\n  git checkout -i [-a] [TAIL_ARGS...]\n  git checkout -i -h\n\n'
            printf >&2 'Press enter to select a branch to check out.\nThe selected branch to check out will be added to history.\n\n'
            printf >&2 'Arguments:\n  -i: Interactive checkout\n  -a: Include non-local refs\n  TAIL_ARGS: Arguments passed to tail to limit checkout choices\n  -h: This message\n\n'
            printf >&2 'Examples:\n  git checkout -i\n  git checkout -ia\n  git checkout -i -a -10\n  git checkout -ia10\n'
            return;;
        -a) refs="--"; shift;;
        -a*) refs="--"; one="${1/#-a/-}"; shift; set -- "$one" "$@";;
        *) refs="refs/heads/"; one="${1/#-i/-}"; [[ "$#" -gt 0 ]] && shift && [[ "$one" != "-" ]] && set -- "$one" "$@";;
    esac
    # old git for-each-ref does not accept --color flag, new git for-each-ref only accepts --color flag
    command git for-each-ref --color --count=1 &>/dev/null && cmd=( git for-each-ref --color ) || cmd=( git -c color.ui=always for-each-ref )
    format="--format=%(refname) %00%(committerdate:format:%s)%(taggerdate:format:%s)%(color:red)%(committerdate:relative)%(taggerdate:relative)%(color:reset)%09%00%(color:yellow)%(refname:short)%(color:reset) %00%(subject)%00 %(color:reset)%(color:dim cyan)<%(color:reset)%(color:cyan)%(authorname)%(taggername)%(color:reset)%(color:dim cyan)>%(color:reset)"
    branches="$(command "${cmd[@]}" "$format" "$refs" |
        perl -ne 'next if /^refs\/stash /; s/^refs\/tags\/[^\x00]*\x00([^\x00]*)\x00([^\x00]*)/\1(tag) \2/ || s/^[^\x00]*\x00([^\x00]*)\x00/$1/; s/\x00([^\x00]{0,50})([^\x00]*)\x00/$1\x1b[1;30m$2\x1b[0m/; print' |
        sort -k1,1 | cut -c11- | tail "${@:-+0}")" &&
        line_count=$(( $(wc -l <<< "$branches") )) &&
        term_height=$(tput lines) &&
        fzf_height=$(( line_count + 2 < term_height / 2 ? line_count + 2 : term_height / 2 )) &&
        branch=$(echo "$branches" |
        fzf-tmux -d "$fzf_height" -- --no-multi --reverse --tac --ansi --no-sort --height="$fzf_height") &&
        branch="$(echo "$branch" | REMOTES="$(git remote)" perl -pe 's/\x1b\[[0-9;]*m//g; s/^([^\t]*\t)\(tag\) (.*)$/$1refs\/tags\/$2/; s/^[^\t]*\t([^ ]*).*$/$1/; my @remotes = split /\n/, $ENV{REMOTES}; foreach my $remote (@remotes) { s/^$remote\///; }')" &&
        checkout_command="$(printf 'git checkout %q\n' "$branch")" &&
        echo "$checkout_command" &&
        { { builtin history -a && builtin history -s "git checkout -i" && builtin history -s "$checkout_command" && builtin history -a; } &>/dev/null ||
            builtin print -S "$checkout_command" &>/dev/null ||
            echo "Could not save git checkout command to history"; } &&
        command git checkout "$branch"
}

set_iterm_tab_rgb() {
    [[ "$TERM_PROGRAM" != "iTerm.app" ]] && return
    [[ -n "${NO_ITERM_TAB_COLOR+set}" ]] && return
    if [[ -z "$@" ]]; then
        echo -ne "\033]6;1;bg;*;default\a"  # reset
    else
        echo -ne "\033]6;1;bg;red;brightness;${1}\a\033]6;1;bg;green;brightness;${2}\a\033]6;1;bg;blue;brightness;${3}\a"
    fi
}

work_on_repository() {
    local main_command='
        cd ~/code/'"$1"'/product
        . ../infrastructure/set.env.sh'
    if [[ "$2" == 'here' ]]; then
        eval "$main_command"
        return
    fi
    # set.env.sh borks out if run twice, so reset the environment
    # assume it's a login shell for now
    # OS X messes with the path in /etc/profile and /etc/zprofile. FIXPATH works around this
    exec env -i ORIGINAL_VARS="$ORIGINAL_VARS" "$(command -v bash)" --noprofile -c '
        eval "$ORIGINAL_VARS"
        '"$main_command"'
        FIXPATH="$PATH" exec $(command -v bash) -l'
}

apply_aliases() {
    # ls
    if [[ "$OSTYPE" == "darwin"* ]]; then
        export CLICOLOR=1
        export LSCOLORS=gxBxhxDxfxhxhxhxhxcxcx
        alias ls="ls -Gp"
    fi
    if [[ "$OSTYPE" == "linux-gnu" ]]; then
        alias ls="ls --color=auto -p"
        alias pbcopy='xsel --clipboard --input'
        alias pbpaste='xsel --clipboard --output'
    fi
    if [[ "$OSTYPE" == "cygwin" ]]; then
        alias ls="ls --color=auto -p"
        #alias pbcopy='clip'
        alias pbcopy='dd of=/dev/clipboard status=none'
        alias pbpaste='dd if=/dev/clipboard status=none'
    fi
    alias l="ls"
    alias la="ls -a"
    alias ll="ls -la"
    alias lr="ls -R"
    alias lz="ls -rS"  # sort by size
    alias lt="ls -rT"  # sort by timestamp
    alias lathr="ls -lathr"
    alias althr="ls -lathr"

    # modified commands
    command -v gtar &>/dev/null && alias tar="gtar"
    command -v colordiff &>/dev/null && alias diff="colordiff"
    command -v wget &>/dev/null && alias wget="wget --content-disposition"
    command -v pygmentize &>/dev/null && alias ccat="pygmentize -g"  # pip install Pygments
    alias more="less"
    alias df="df -h"
    alias du="du -ch"

    alias tmux='tmux -2'
}
apply_aliases && unset -f apply_aliases

command -v lesspipe.sh &>/dev/null && export LESSOPEN="|lesspipe.sh %s" LESS_ADVANCED_PREPROCESSOR=1

command -v direnv &>/dev/null && eval "$(direnv hook bash)"

pws() {
    # /usr/local/bin -> /u/l/bin
    # ~/code/srv/src -> ~/c/s/src
    # Edge case: ~/._.foo/bar -> ~/._.f/b
    pwd | awk -v home="$HOME" '{
        if(substr($0,0,length(home)) == home) {
            $0 = "~" substr($0,length(home))
        }
        len = split($0,dirs,"/");
        for(i = 1; i <= len; i++) {
            if(i < len) {
                match(dirs[i], /^[._]*./)
                printf substr(dirs[i], RSTART, RLENGTH)"/"
            } else {
                print dirs[i]
            }
        }
    }'

    ## 55% slower than awk
    #pwd | HOME="$HOME" perl -ne '
    #    $_ =~ s/^\Q$ENV{HOME}\E/~/;
    #    my @dirs = split("/", $_);
    #    my $basename = pop @dirs;
    #    foreach $dir (@dirs) {
    #        print $dir =~ /^(\.*.)/;
    #        print "/";
    #    }
    #    print $basename;
    #'

    ## 53% slower than awk
    #pwd|HOME="$HOME" perl -ne 's/^\Q$ENV{HOME}\E/~/;s/(?<=\/)([._]*.)[^\/]*(?=\/)/\1/g;s/^\.$//;print;'
}

[[ -f ~/.bash.colors ]] && . ~/.bash.colors

# Choose a unique color based on the hostname
# Inspired by http://zork.net/~st/jottings/Per-Host_Prompt_Colouring.html
# rgb2short function derived from https://gist.github.com/MicahElliott/719710
HOSTHASH=$(hostname | if command -v md5sum &>/dev/null; then md5sum; else md5; fi)
{ IFS= read -r HOSTCOLORNUMBER; IFS= read -r HOSTTEXTNUMBER; } <<<"$(hosthash=${HOSTHASH:0:6} color_count=$(tput colors) python -c '
import os
import colorsys
def linear_map(n, min, max, tmin, tmax):
    [n, min, max, tmin, tmax] = [float(i) for i in [n, min, max, tmin, tmax]]
    return (n - min)/(max - min) * (tmax - tmin) + tmin
hosthash = os.environ["hosthash"]
h = linear_map(int(hosthash[0:2], 16), 0, 0xff, 0, 1)
s = linear_map(int(hosthash[2:4], 16), 0, 0xff, 0.5, 1)
l = linear_map(int(hosthash[4:6], 16), 0, 0xff, 0.2, 0.8)
rgb = [0xff * i for i in colorsys.hls_to_rgb(h, l, s)]
cubelevels = [0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff]
snaps = [(x+y)/2 for x, y in list(zip(cubelevels, [0]+cubelevels))[1:]]
def rgb2short256(r, g, b):
    r, g, b = map(lambda x: len(tuple(s for s in snaps if s<x)), (r, g, b))
    print(r*36 + g*6 + b + 16)
    print(15 if l < 0x6c / 0xff or ( 0x95 / 0xff < h < 0xc0 / 0xff and l < 0xa6 / 0xff ) else 0)
hues = [1, 3, 2, 6, 4, 5, 1]
def hl2short(h, l, color_count):
    h = hues[int(round(linear_map(h, 0, 1, 0, 6)))]
    color = h + 8 if l > .6 and color_count == 16 else h
    print(color)
    print(7 if color == 4 and color_count == 8 else 15 if color == 4 else 0)
color_count = int(os.environ["color_count"])
rgb2short256(*rgb) if color_count >= 256 else hl2short(h, l, color_count)
')"
HOSTBGCOLOR=$(tput setab "$HOSTCOLORNUMBER")
HOSTFGCOLOR=$(tput setaf "$HOSTCOLORNUMBER")
HOSTBGTEXT=$(tput setab "$HOSTTEXTNUMBER")
HOSTFGTEXT=$(tput setaf "$HOSTTEXTNUMBER")

if [[ $EUID == '0' ]]; then
    # running as root or with privileges
    PROMPT_ROOT_FLAG="\[\e[0;31;41m\]/\[\e[1;37m\]!\[\e[0;31;41m\]\\\\\[$X\]"
else
    PROMPT_ROOT_FLAG=''
fi

PROMPT_COMMAND='history -a;echo -en "\033]0;$(pwd|HOME="$HOME" perl -ne '"'"'s/^\Q$ENV{HOME}\E/~/;s/(?<=\/)([._]*.)[^\/]*(?=\/)/\1/g;s/^\.$//;print;'"'"')\007"'

PS1="\u@\h:\w"'$(__git_info)'$'\n'"\\\$ "
PS1="$PROMPT_ROOT_FLAG\[$HOSTFGCOLOR$HOSTBGCOLOR\][\[$HOSTFGTEXT$HOSTBGCOLOR\]\u \[$K$BGW\] \h\[$W$BGW\]]\[$X\e[0;100m\e[37m\] \w \[$X\]"'$(__git_info)'$'\n'"\[$X\e[1m\]\\\$\[$X\] "

__git_info() {
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        return
    fi
    local message branch remote_ref remote commit_hash detached_tag detached_from tracking ahead behind gitstatus base stashes stash_message staged_changes unstaged_changes
    base=$(git rev-parse --show-toplevel)
    # On a branch?
    branch=$(git symbolic-ref --short -q HEAD)
    # On a remote-tracking branch?
    remote_ref=$(git rev-parse --verify "${branch}@{upstream}" --symbolic-full-name 2>/dev/null)
    remote=${remote_ref/refs\/remotes\/}
    commit_hash=$(git rev-parse --verify --short=7 HEAD 2>/dev/null)
    staged_changes="$(git diff-index --cached --quiet HEAD -- || echo 'S')"
    unstaged_changes="$(git diff-files --quiet || echo 'U')"
    if [[ -z ${branch} ]] ; then
        detached_tag=$(git describe --tags --exact-match 2>/dev/null)
        detached_from=${detached_tag:-${commit_hash}}
        tracking="[detached from ${detached_from}]"
    elif [[ -n ${remote} ]] ; then
        ahead=$(git rev-list "${branch}@{upstream}..HEAD" 2>/dev/null | wc -l | tr -d ' ')
        (( $ahead )) && gitstatus+="+${ahead}"
        behind=$(git rev-list "HEAD..${branch}@{upstream}" 2>/dev/null | wc -l | tr -d ' ')
        (( $behind )) && gitstatus="${gitstatus:+$gitstatus/}-${behind}"
        tracking="[${remote}${gitstatus:+ ${gitstatus}}]"
    fi
    if git rev-parse --quiet --verify refs/stash &>/dev/null; then
        stashes=$(git rev-list --walk-reflogs --count refs/stash)
        stash_message="(${stashes} stashed)"
    fi
    message="(git)"
    [[ -n "${commit_hash}" ]] && message+=" ${commit_hash}"
    [[ -n "${staged_changes}" ]] && message+=" ${staged_changes}"
    [[ -n "${unstaged_changes}" ]] && message+=" ${unstaged_changes}"
    [[ -n "${branch}" ]] && message+=" ${branch}"
    [[ -n "${tracking}" ]] && message+=" ${tracking}"
    [[ -n "${stash_message}" ]] && message+=" ${stash_message}"
    echo -en "\n${message}"
}

#[[ -f ~/.bashrc.local ]] && . ~/.bashrc.local
