#!/usr/bin/env python

import os
import glob
import signal
import sys
import textwrap
import re
import subprocess

# Python 2/3 compatibility
try:
    input = raw_input
except NameError:
    pass

dotfile_directory = os.path.dirname(os.path.realpath(__file__))
dotfile_directory_files = glob.glob(dotfile_directory + '/*')
file_blacklist = [os.path.basename(__file__), 'README.md', 'Makefile', 'tags']


def main():
    print(textwrap.dedent("""
        Update the dotfiles by running "git pull" in {}
        Check README.md for changes when you update.
        """).strip().format(dotfile_directory))
    dotfiles, executables = gather_dotfiles()
    symlink_dotfiles(dotfiles)
    execute_executables(executables)


def gather_dotfiles():
    dotfiles = []
    executables = []
    for dotfile in dotfile_directory_files:
        dotfile_name = os.path.basename(dotfile)
        if not os.path.isfile(dotfile):
            continue
        if dotfile_name in file_blacklist:
            continue
        if dotfile_name.endswith('.disabled'):
            continue
        if os.access(dotfile, os.X_OK):
            executables.append(dotfile)
        else:
            dotfiles.append(dotfile)
    return dotfiles, executables


def symlink_dotfiles(dotfiles):
    for dotfile in dotfiles:
        dotfile_name = os.path.basename(dotfile)
        install_location = os.path.join(
            os.path.expanduser('~'), '.' + dotfile_name)
        if os.path.exists(install_location):
            short_install_location = substitute_home(install_location)
            short_dotfile = substitute_home(dotfile)
            if os.path.realpath(install_location) != dotfile:
                print(short_install_location + ' already exists and is not symlinked to ' + short_dotfile + ', skipping')
            else:
                print(short_install_location + ' already exists, skipping')
            continue
        skip_file = os.path.join(
                os.path.dirname(dotfile),
                '.{}.skip'.format(os.path.basename(dotfile)))
        if os.path.exists(skip_file):
            short_skip_file = substitute_home(skip_file)
            print(short_skip_file + ' exists, skipping')
            continue
        install = input('Symlink ' + dotfile_name + '? [Y/n]: ')
        if not (install == '' or install.lower() == 'y'):
            create_empty_file(skip_file)
            continue
        print('Symlink ' + dotfile + ' to ' + install_location)
        os.symlink(dotfile, install_location)


def execute_executables(executables):
    for executable in executables:
        run = input('Execute ' + executable + '? (read first!) [Y/n]: ')
        if not (run == '' or run.lower() == 'y'):
            continue
        print('Execute ' + executable)
        subprocess.Popen([executable], cwd=dotfile_directory).wait()


def create_empty_file(file_path):
    open(file_path, 'a').close()


def substitute_home(path):
    return re.sub(re.escape(os.path.expanduser('~')), '~', path, 1)


def handle_sigint():
    def clean_exit(signal, frame):
        print('')
        sys.exit(0)
    signal.signal(signal.SIGINT, clean_exit)


if __name__ == '__main__':
    handle_sigint()
    main()
