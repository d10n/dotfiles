#!/usr/bin/env python

import os
import glob
import signal
import sys
import textwrap
import re
import errno
import subprocess

# Python 2/3 compatibility
try:
    input = raw_input
except NameError:
    pass

dotfile_directory = os.path.dirname(os.path.realpath(__file__))


def main():
    config_default, config_local = read_configs()
    config_discovered = discover_unknown(config_default, config_local)
    config_local = symlink_dotfiles(config_default, config_local, config_discovered)
    config_local = execute_executables(config_default, config_local, config_discovered)
    config_local.save()

    print(textwrap.dedent("""
        Update the dotfiles by running "git pull" and "./install" in {}
        Check git log and README.md for changes when you update.
        """).format(substitute_home(dotfile_directory)))


class Config(object):
    def __init__(self, file_path=None):
        self.file_path = file_path
        self.items = {
            'symlink': {},
            'execute': {},
            'ignore': {},
        }
        if not file_path or not os.path.exists(file_path):
            return
        state = None
        with open(file_path) as file:
            for line in file:
                line = line.rstrip('\n')
                section = re.findall(r'^\[(.*)\]$', line)
                if section:
                    state = section[0]
                elif state in self.items.keys() and line:
                    srcdest = re.findall(r'^([^=]*) = (.*)$', line)
                    if srcdest:
                        src, dest = srcdest[0]
                        self.items[state][src] = dest or None
                    else:
                        self.items[state][line] = None

    def save(self):
        with open(self.file_path, 'w') as file:
            for section in 'symlink', 'execute', 'ignore':
                file.write('[' + section + ']\n\n')
                section_items = ''
                for src, dest in sorted(self.items[section].items()):
                    if dest:
                        section_items += src + ' = ' + dest
                    else:
                        section_items += src
                    section_items += '\n'
                if section_items:
                    file.write(section_items + '\n')
        self.warn_overlap()

    def warn_overlap(self):
        symlink_execute = sorted(set(self['symlink']) & set(self['execute']))
        symlink_ignore = sorted(set(self['symlink']) & set(self['ignore']))
        execute_ignore = sorted(set(self['execute']) & set(self['ignore']))
        if symlink_execute:
            print('\nWarning: these entries are configured to both symlink and execute:')
            print(symlink_execute)
        if symlink_ignore:
            print('\nWarning: these entries are configured to both symlink and ignore:')
            print(symlink_ignore)
        if execute_ignore:
            print('\nWarning: these entries are configured to both execute and ignore:')
            print(execute_ignore)

    def __getitem__(self, item):
        return self.items.__getitem__(item)

    def __setitem__(self, item, value):
        return self.items.__setitem__(item, value)


def read_configs():
    config_default_file = os.path.join(dotfile_directory, 'install-config.txt')
    config_local_file = os.path.join(dotfile_directory, 'install-config.local.txt')
    config_default = Config(config_default_file)
    config_default['ignore'][os.path.basename(__file__)] = None
    config_default['ignore'][os.path.basename(config_default_file)] = None
    config_default['ignore'][os.path.basename(config_local_file)] = None
    config_local = Config(config_local_file)
    return config_default, config_local


def discover_unknown(config_default, config_local):
    config_discovered = Config()
    configured_items = {}
    for section in 'symlink', 'execute', 'ignore':
        configured_items.update(config_default[section])
        configured_items.update(config_local[section])
    dotfile_directory_files = glob.glob(dotfile_directory + '/*')
    for file in dotfile_directory_files:
        dotfile_name = os.path.basename(file)
        if dotfile_name not in configured_items:
            if os.access(file, os.X_OK) and not os.path.isdir(file):
                config_discovered['execute'][dotfile_name] = None
            else:
                config_discovered['symlink'][dotfile_name] = None
    return config_discovered


def symlink_dotfiles(config_default, config_local, config_discovered):
    symlinks = {}
    symlinks.update(config_default['symlink'])
    symlinks.update(config_local['symlink'])
    symlinks.update(config_discovered['symlink'])
    for dotfile_name, dotfile_dest in sorted(symlinks.items()):
        dotfile = os.path.join(dotfile_directory, dotfile_name)
        if dotfile_dest:
            install_location = os.path.expanduser(dotfile_dest)
        else:
            install_location = os.path.join(
                os.path.expanduser('~'), '.' + dotfile_name)
        if os.path.exists(install_location) or os.path.islink(install_location):
            short_install_location = substitute_home(install_location)
            short_dotfile = substitute_home(dotfile)
            if os.path.realpath(install_location) != dotfile:
                print(short_install_location + ' already exists and is not symlinked to ' +
                      short_dotfile + ', skipping')
            else:
                print(short_install_location + ' already exists, skipping')
            continue
        if dotfile_name in config_local['ignore']:
            print(dotfile_name + ' is ignored; skipping')
            continue
        if dotfile_dest:
            prompt = 'Symlink ' + dotfile_name + ' to ' + dotfile_dest + '? y=yes n=no q=quit [Y/n/q]: '
        else:
            prompt = 'Symlink ' + dotfile_name + '? y=yes n=no q=quit [Y/n/q]: '
        install = input(prompt)
        if install.lower() == 'q':
            config_local.save()
            exit(0)
        if not (install == '' or install.lower() == 'y'):
            if dotfile_name in config_local['symlink']:
                continue
            config_local['ignore'][dotfile_name] = dotfile_dest
            print('Ignore ' + dotfile_name)
            continue
        if dotfile_name not in config_default['symlink']:
            config_local['symlink'][dotfile_name] = dotfile_dest
        print('Symlink ' + dotfile_name + ' to ' + install_location)
        if not os.path.exists(os.path.dirname(install_location)):
            mkdir_p(os.path.dirname(install_location))
        os.symlink(dotfile, install_location)
    return config_local


def execute_executables(config_default, config_local, config_discovered):
    config_local = execute_configured_executables(config_default, config_local)
    config_local = execute_discovered_executables(config_local, config_discovered)
    return config_local


def execute_configured_executables(config_default, config_local):
    configured = set(config_default['execute'].keys()).union(set(config_local['execute'].keys()))
    for executable in sorted(configured):
        executable_name = executable
        executable = os.path.join(dotfile_directory, executable)
        if executable_name in config_local['execute']:
            run = input('Execute ' + executable_name +
                        '? (verify first!) y=yes n=no q=quit [Y/n/q]: ')
        elif executable_name in config_default['execute']:
            run = input('Execute ' + executable_name +
                        '? (verify first!) y=yes n=no i=ignore q=quit [Y/n/i/q]: ')
            if run.lower() == 'i':
                config_local['ignore'][executable_name] = None
                print('Ignore ' + executable_name)
                continue
        if run.lower() == 'q':
            config_local.save()
            exit(0)
        if not (run == '' or run.lower() == 'y'):
            continue
        print('Execute ' + executable)
        subprocess.Popen([executable], cwd=dotfile_directory).wait()
    return config_local


def execute_discovered_executables(config_local, config_discovered):
    for executable in sorted(set(config_discovered['execute'].keys())):
        executable_name = executable
        executable = os.path.join(dotfile_directory, executable)
        run = input('Execute ' + executable_name +
                    '? (verify first!) y=yes n=no i=ignore l=symlink q=quit [Y/n/i/l/q]: ')
        if run.lower() == 'q':
            config_local.save()
            exit(0)
        if run.lower() == 'i':
            config_local['ignore'][executable_name] = None
            print('Ignore ' + executable_name)
            continue
        if run.lower() == 'l':
            install_location = os.path.join(
                os.path.expanduser('~'), '.' + executable_name)
            config_local['symlink'][executable_name] = None
            print('Symlink ' + executable_name + ' to ' + install_location)
            os.symlink(executable, install_location)
            continue
        if not (run == '' or run.lower() == 'y'):
            continue
        config_local['execute'][executable_name] = None
        print('Execute ' + executable)
        subprocess.Popen([executable], cwd=dotfile_directory).wait()
    return config_local


def substitute_home(path):
    home_path = os.path.expanduser('~')
    if path.startswith(home_path):
        return path.replace(home_path, '~', 1)
    return path


def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise


def handle_sigint():
    def clean_exit(signal, frame):
        print('')
        sys.exit(0)
    signal.signal(signal.SIGINT, clean_exit)


if __name__ == '__main__':
    handle_sigint()
    main()
