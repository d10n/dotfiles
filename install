#!/usr/bin/env python

import os
import glob
import signal
import sys
import textwrap
import re
import errno
import subprocess

# Python 2/3 compatibility
try:
    input = raw_input
except NameError:
    pass

dotfile_directory = os.path.dirname(os.path.realpath(__file__))


def main():
    config_default, config_local = read_configs()
    config_discovered = discover_unknown(config_default, config_local)
    config_local = symlink_dotfiles(config_default, config_local, config_discovered)
    config_local = execute_executables(config_default, config_local, config_discovered)
    config_local.save()

    print(textwrap.dedent("""
        Update the dotfiles by running "git pull" and "./install" in {}
        Check git log and README.md for changes when you update.
        """).format(substitute_home(dotfile_directory)))


class Config(object):
    def __init__(self, file_path=None):
        self.file_path = file_path
        self.items = {
            'symlink': {},
            'execute': {},
            'ignore': {},
        }
        if not file_path or not os.path.exists(file_path):
            return
        state = None
        with open(file_path) as file:
            for line in file:
                line = line.rstrip('\n')
                section = re.findall(r'^\[(.*)\]$', line)
                if section:
                    state = section[0]
                elif state in self.items.keys() and line:
                    srcdest = re.findall(r'^([^=]*) = (.*)$', line)
                    if srcdest:
                        src, dest = srcdest[0]
                        self.items[state][src] = dest or None
                    else:
                        self.items[state][line] = None

    def save(self):
        with open(self.file_path, 'w') as file:
            for section in 'symlink', 'execute', 'ignore':
                file.write('[' + section + ']\n\n')
                section_items = ''
                for src, dest in sorted(self.items[section].items()):
                    if dest:
                        section_items += src + ' = ' + dest
                    else:
                        section_items += src
                    section_items += '\n'
                if section_items:
                    file.write(section_items + '\n')
        self.warn_overlap()

    def warn_overlap(self):
        symlink_execute = sorted(set(self['symlink']) & set(self['execute']))
        symlink_ignore = sorted(set(self['symlink']) & set(self['ignore']))
        execute_ignore = sorted(set(self['execute']) & set(self['ignore']))
        if symlink_execute:
            print('\nWarning: these entries are configured to both symlink and execute:')
            print(symlink_execute)
        if symlink_ignore:
            print('\nWarning: these entries are configured to both symlink and ignore:')
            print(symlink_ignore)
        if execute_ignore:
            print('\nWarning: these entries are configured to both execute and ignore:')
            print(execute_ignore)

    def __getitem__(self, item):
        return self.items.__getitem__(item)

    def __setitem__(self, item, value):
        return self.items.__setitem__(item, value)


def read_configs():
    config_default_file = os.path.join(dotfile_directory, 'install-config.txt')
    config_local_file = os.path.join(dotfile_directory, 'install-config.local.txt')
    config_default = Config(config_default_file)
    config_default['ignore'][os.path.basename(__file__)] = None
    config_default['ignore'][os.path.basename(config_default_file)] = None
    config_default['ignore'][os.path.basename(config_local_file)] = None
    config_local = Config(config_local_file)
    return config_default, config_local


def discover_unknown(config_default, config_local):
    config_discovered = Config()
    configured_items = {}
    for section in 'symlink', 'execute', 'ignore':
        configured_items.update(config_default[section])
        configured_items.update(config_local[section])
    dotfile_directory_files = glob.glob(dotfile_directory + '/*')
    for file in dotfile_directory_files:
        dotfile_name = os.path.basename(file)
        if dotfile_name not in configured_items:
            if os.access(file, os.X_OK) and not os.path.isdir(file):
                config_discovered['execute'][dotfile_name] = None
            else:
                config_discovered['symlink'][dotfile_name] = None
    return config_discovered


def symlink_dotfiles(config_default, config_local, config_discovered):
    symlinks = {}
    symlinks.update(config_default['symlink'])
    symlinks.update(config_local['symlink'])
    symlinks.update(config_discovered['symlink'])
    for dotfile_name, dotfile_dest in sorted(symlinks.items()):
        dotfile_path = os.path.join(dotfile_directory, dotfile_name)
        if dotfile_dest:
            install_location = os.path.expanduser(dotfile_dest)
        else:
            install_location = os.path.join(
                os.path.expanduser('~'), '.' + dotfile_name)
        if os.path.exists(install_location) or os.path.islink(install_location):
            short_install_location = substitute_home(install_location)
            short_dotfile = substitute_home(dotfile_path)
            if os.path.realpath(install_location) != dotfile_path:
                print(short_install_location + ' already exists and is not symlinked to ' +
                      short_dotfile + ', skipping')
            else:
                print(short_install_location + ' already exists, skipping')
            continue
        if dotfile_name in config_local['ignore']:
            print(dotfile_name + ' is ignored; skipping')
            continue
        if dotfile_dest:
            prompt = 'Symlink ' + dotfile_name + ' to ' + substitute_home(install_location) + '? y=yes n=no q=quit [Y/n/q]: '
        else:
            prompt = 'Symlink ' + dotfile_name + '? y=yes n=no q=quit [Y/n/q]: '
        config_local = do_prompt(prompt, 'ynq',
                                 dotfile_name, dotfile_path, dotfile_dest,
                                 config_default, config_local, 'i', 'l')
    return config_local


def execute_executables(config_default, config_local, config_discovered):
    config_local = execute_configured_executables(config_default, config_local)
    config_local = execute_discovered_executables(config_local, config_discovered)
    return config_local


def execute_configured_executables(config_default, config_local):
    configured = set(config_default['execute'].keys()).union(set(config_local['execute'].keys()))
    for executable in sorted(configured):
        executable_name = executable
        executable = os.path.join(dotfile_directory, executable)
        if executable_name in config_local['execute']:
            prompt = 'Execute ' + executable_name + '? (verify first!) y=yes n=no q=quit [Y/n/q]: '
            valid_actions='ynq'
        elif executable_name in config_default['execute']:
            prompt = 'Execute ' + executable_name + '? (verify first!) y=yes n=no i=ignore q=quit [Y/n/i/q]: '
            valid_actions='yniq'
        else:
            continue
        config_local = do_prompt(prompt, valid_actions,
                                 executable_name, executable, None,
                                 config_default, config_local, 's', 'x')
    return config_local


def execute_discovered_executables(config_local, config_discovered):
    for executable in sorted(set(config_discovered['execute'].keys())):
        executable_name = executable
        executable = os.path.join(dotfile_directory, executable)
        prompt = ('Execute ' + executable_name +
                  '? (verify first!) y=yes n=no i=ignore l=symlink q=quit [Y/n/i/l/q]: ')
        config_local = do_prompt(prompt, 'ynilq',
                                 executable_name, executable, None,
                                 None, config_local, 's', 'x')
    return config_local


def do_prompt(prompt, valid_actions,
              item_name, item_path, item_dest,
              config_default, config_local,
              action_n, action_y, action_default='y'):
    while True:
        action = input(prompt)
        if not action:
            action = action_default
        action = action.lower()
        if action in valid_actions:
            break
        print('Invalid input.')
    if action == 'y':
        action = action_y
    if action == 'n':
        action = action_n
    if action == 'q':
        config_local.save()
        exit(0)
    if action == 's':
        print('Skip ' + item_name)
    if action == 'i':
        ignore(config_default, config_local, item_name, item_dest)
    if action == 'l':
        symlink(config_default, config_local, item_name, item_path, item_dest)
    if action == 'x':
        execute(config_default, config_local, item_name, item_path)
    return config_local


def ignore(config_default, config_local, item_name, item_dest):
    if ((config_default is None or item_name not in config_default['ignore']) and
            item_name not in set(config_local['symlink']) | set(config_local['execute'])):
        config_local['ignore'][item_name] = item_dest
        print('Ignore ' + item_name)
    else:
        print('Skip ' + item_name)


def symlink(config_default, config_local, item_name, item_path, item_dest):
    if item_dest:
        install_location = os.path.expanduser(item_dest)
    else:
        install_location = os.path.join(
            os.path.expanduser('~'), '.' + item_name)
    if config_default is None or item_name not in config_default['symlink']:
        config_local['symlink'][item_name] = item_dest
    print('Symlink ' + item_name + ' to ' + install_location)
    if not os.path.exists(os.path.dirname(install_location)):
        mkdir_p(os.path.dirname(install_location))
    os.symlink(item_path, install_location)


def execute(config_default, config_local, item_name, item_path):
    if config_default is None or item_name not in config_default['execute']:
        config_local['execute'][item_name] = None
    print('Execute ' + item_path)
    subprocess.Popen([item_path], cwd=dotfile_directory).wait()


def substitute_home(path):
    home_path = os.path.expanduser('~')
    if path.startswith(home_path):
        return path.replace(home_path, '~', 1)
    return path


def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise


def handle_sigint():
    def clean_exit(signal, frame):
        print('')
        sys.exit(0)
    signal.signal(signal.SIGINT, clean_exit)


if __name__ == '__main__':
    handle_sigint()
    main()
